{
  "name": "angular-expressions",
  "version": "0.2.1",
  "description": "Angular expressions as standalone module",
  "main": "./lib/main.js",
  "scripts": {
    "test": "node node_modules/mocha/bin/mocha test/main.test.js -R spec",
    "test-browser": "node node_modules/webpack-dev-server/bin/webpack-dev-server.js mocha\\!./test/main.test.js -d"
  },
  "keywords": [
    "angular",
    "expression",
    "parser",
    "lexer",
    "parse",
    "eval",
    "source"
  ],
  "dependencies": {},
  "devDependencies": {
    "mocha": "1.x",
    "chai": "1.x",
    "webpack-dev-server": "1.x",
    "mocha-loader": "0.x"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/peerigon/angular-expressions.git"
  },
  "testling": {
    "harness": "mocha",
    "files": "test/main.js",
    "browsers": [
      "ie/8..latest",
      "chrome/27..latest",
      "firefox/22..latest",
      "safari/latest",
      "opera/latest",
      "iphone/latest",
      "ipad/latest",
      "android-browser/latest"
    ]
  },
  "author": {
    "name": "peerigon",
    "email": "developers@peerigon.com"
  },
  "license": "Unlicense",
  "bugs": {
    "url": "https://github.com/peerigon/angular-expressions/issues"
  },
  "homepage": "https://github.com/peerigon/angular-expressions",
  "_id": "angular-expressions@0.2.1",
  "dist": {
    "shasum": "e2beede256578dbd14235b98169d64485b29e927",
    "tarball": "http://registry.npmjs.org/angular-expressions/-/angular-expressions-0.2.1.tgz"
  },
  "_from": "angular-expressions@~0.2.1",
  "_npmVersion": "1.3.17",
  "_npmUser": {
    "name": "peerigon",
    "email": "developers@peerigon.com"
  },
  "maintainers": [
    {
      "name": "peerigon",
      "email": "developers@peerigon.com"
    }
  ],
  "directories": {},
  "_shasum": "e2beede256578dbd14235b98169d64485b29e927",
  "_resolved": "https://registry.npmjs.org/angular-expressions/-/angular-expressions-0.2.1.tgz",
  "readme": "angular-expressions\r\n===================\r\n\r\n[angular's expressions](https://github.com/angular/angular.js/blob/6b049c74ccc9ee19688bb9bbe504c300e61776dc/src/ng/parse.js) extracted as a standalone module for the browser and node. Check out [their readme](http://docs.angularjs.org/guide/expression) for further information.\r\n\r\n<br />\r\n\r\nSetup\r\n-----\r\n\r\n[![npm status](https://nodei.co/npm/angular-expressions.png?downloads=true&stars=true)](https://npmjs.org/package/angular-expressions)\r\n\r\n[![build status](https://travis-ci.org/peerigon/angular-expressions.png)](http://travis-ci.org/peerigon/angular-expressions)\r\n\r\n[![browser support](https://ci.testling.com/peerigon/angular-expressions.png)\r\n](https://ci.testling.com/peerigon/angular-expressions)\r\n\r\n<br />\r\n\r\nUsage\r\n-----\r\n\r\n```javascript\r\nvar expressions = require(\"angular-expressions\"),\r\n    scope,\r\n    expr;\r\n\r\nexpr = expressions.compile(\"1 + 1\");\r\nexpr(); // returns 2\r\n\r\nexpr = expressions.compile(\"name\");\r\nscope = { name: 'Jenny' };\r\nexpr(scope); // returns 'Jenny'\r\n\r\nexpr = expressions.compile(\"ship.pirate.name = 'Störtebeker'\");\r\nscope = {};\r\nexpr(scope); // won't throw an error because angular's expressions are forgiving\r\n\r\nconsole.log(scope.ship.pirate.name); // prints 'Störtebeker'\r\n```\r\n\r\n<br />\r\n\r\nFilters\r\n-------------\r\n\r\nAngular provides a mechanism to define filters on expressions:\r\n\r\n```javascript\r\nexpressions.filters.uppercase = function (input) {\r\n    return input.toUpperCase();\r\n};\r\n\r\nexpr = expressions.compile(\"'arr' | uppercase\");\r\nexpr(); // returns 'ARR'\r\n```\r\n\r\nArguments are evaluated against the scope:\r\n\r\n```javascript\r\nexpressions.filters.currency = function (input, currency, digits) {\r\n    input = input.toFixed(digits);\r\n\r\n    if (currency === \"EUR\") {\r\n        return input + \"€\";\r\n    } else {\r\n        return input + \"$\";\r\n    }\r\n};\r\n\r\nexpr = expressions.compile(\"1.2345 | currency:selectedCurrency:2\");\r\nexpr({\r\n    selectedCurrency: \"EUR\"\r\n}); // returns '1.23€'\r\n```\r\n\r\n<br />\r\n\r\nAPI\r\n---\r\n\r\n### .compile(src: String): Function&lt;target?&gt;\r\nCompiles `src` and returns a function that executes `src` on a `target` object. The compiled function is cached under `compile.cache[src]` to speed up further calls.\r\n\r\n### .compile.cache: Object|Boolean\r\n\r\nA cache containing all compiled functions. The src is used as key. Set this on `false` to disable the cache.\r\n\r\n### .filters: Object\r\n\r\nAn empty object where you may define your custom filters.\r\n\r\n### .Lexer: Lexer\r\n\r\nThe internal [Lexer](https://github.com/angular/angular.js/blob/6b049c74ccc9ee19688bb9bbe504c300e61776dc/src/ng/parse.js#L116).\r\n\r\n### .Parser: Parser\r\n\r\nThe internal [Parser](https://github.com/angular/angular.js/blob/6b049c74ccc9ee19688bb9bbe504c300e61776dc/src/ng/parse.js#L390).\r\n\r\n\r\n<br />\r\n\r\nIn the browser\r\n-------------\r\n\r\nThere is no `dist` build because it's not 2005 anymore. Use a module bundler like [webpack](http://webpack.github.io/) or [browserify](http://browserify.org/). They're both capable of CommonJS and AMD.\r\n\r\n<br />\r\n\r\nSecurity\r\n--------\r\n\r\nComment from `angular.js/src/ng/parse.js`:\r\n\r\n---\r\n\r\nAngular expressions are generally considered safe because these expressions only have direct\r\naccess to $scope and locals. However, one can obtain the ability to execute arbitrary JS code by\r\nobtaining a reference to native JS functions such as the Function constructor.\r\n\r\nAs an example, consider the following Angular expression:\r\n\r\n```javascript\r\n{}.toString.constructor(alert(\"evil JS code\"))\r\n```\r\n\r\nWe want to prevent this type of access. For the sake of performance, during the lexing phase we\r\ndisallow any \"dotted\" access to any member named \"constructor\".\r\n\r\nFor reflective calls (a[b]) we check that the value of the lookup is not the Function constructor\r\nwhile evaluating the expression, which is a stronger but more expensive test. Since reflective\r\ncalls are expensive anyway, this is not such a big deal compared to static dereferencing.\r\nThis sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits\r\nagainst the expression language, but not to prevent exploits that were enabled by exposing\r\nsensitive JavaScript or browser apis on Scope. Exposing such objects on a Scope is never a good\r\npractice and therefore we are not even trying to protect against interaction with an object\r\nexplicitly exposed in this way.\r\n\r\nA developer could foil the name check by aliasing the Function constructor under a different\r\nname on the scope.\r\n\r\nIn general, it is not possible to access a Window object from an angular expression unless a\r\nwindow or some DOM object that has a reference to window is published onto a Scope.\r\n\r\n---\r\n\r\n<br />\r\n\r\nAuthorship\r\n----------\r\nKudos go entirely to the great angular.js team, it's their implementation!\r\n\r\n\r\n<br />\r\n\r\nContributing\r\n------------\r\n\r\nSuggestions and bug-fixes are always appreciated. Don't hesitate to create an issue or pull-request. All contributed code should pass\r\n\r\n1. the tests in node.js by running `npm test`\r\n2. the tests in all major browsers by running `npm run test-browser` and then visiting `http://localhost:8080/bundle`\r\n\r\n<br />\r\n\r\nLicense\r\n-------\r\n\r\n[Unlicense](http://unlicense.org/)",
  "readmeFilename": "README.md"
}
